#+options: num:nil
Welcome to Plexsim.
Fast and general toolbox for simulation of complex adaptive systems written in cython.
*N.b.* this is a work in progress. Please see the [[Quickstart]] guide below.

#+attr_html: :alt  :align center :class img
[[file:./banner/new_banner.gif]]

* Installing
- Clone the repo ~git clone git@github.com:cvanelteren/PlexSim.git && cd Plexsim~
- Install the requirements
  - As an env ~conda create env --file environment.yml~
  - In an existing environment ~conda env update~
- ~python setup.py install~
* License
PlexSim is released under the GNU-GPLv3 license

Powered by
#+attr_html: :alt  :align right :class img
[[file:./banner/cython_logo.svg]]

* Quickstart  

Current  versions are  developed on  ~linux~. It  is known  that compiling  with
cython on mac is  difficult due to the ~gcc~ compiler  being replaced with ~clang~
on apple.  This toolbox  depends on  ~openmp~ and this  could cause  problems on
~apple~. 


** Setting up the model
Plexsim  relies on  ~networkx~ to  create a  graphical  structure  on which  to
simulate models.  Various models  are available  in ~plexsim.models~.  Below the
Ising model is used
#+begin_src python  :file banner/ising_example.png
from matplotlib import style; style.use("seaborn-poster".split())
import numpy as np, os, sys, networkx as nx, warnings, matplotlib.pyplot as plt
warnings.simplefilter("ignore")

from plexsim import models

# init lattice graph with periodic bounds
g = nx.grid_graph((64, 64), periodic = 1)
# create an ising model
temperature = 2.5

# async with sampleSize > 1, can be seen as sampleSize of glauberupdates in 1 simulation step
settings = dict(graph = g,  # graph for the model
                t = temperature, #temperature for the Ising model
                sampleSize = len(g), #how many nodes to update per simulation step (default)
                updateType = 'async',#the update buffers are not independent, use sync for dependency(default)
                )
m = models.Ising(graph = g, t = temperature)


# create coords an visualize grid with periodic bounds
# leverage the fact that grid returns tuples of coordinates
pos = {i: np.array(eval(i)) for i in m.graph.nodes()}
# create color map for the possible states of the model
colors = plt.cm.viridis(np.linspace(0, 1, m.nStates))
fig, ax = plt.subplots()
nx.draw(m.graph, pos = pos, ax = ax,
        node_color = colors[m.states.astype(int)],
        node_size = 20)
ax.set_title("Ising model with random initial condition", fontsize = 21)
ax.axis('equal')
fig.show()
#+end_src

#+attr_html: :alt  :align center :class img
[[file:./banner/ising_example.png]]


** Simulation 
#+begin_src python  :file banner/ising_time_example.png
n = int(1e2) # simulation steps
m.reset() # reset model to random condition
sim_results = m.simulate(n)
# show averages
spacing = np.linspace(0, n, 4, endpoint = False).astype(int)
fig, ax = plt.subplots(2, 2, figsize = (5,5), constrained_layout = 1)
for idx, axi in zip(spacing, ax.flat):
    tmp = sim_results[idx]
    nx.draw(m.graph, pos = pos, ax = axi, node_color = colors[tmp.astype(int)],
            node_size = 5)
    axi.axis('equal'); axi.axis(True); axi.grid(False)
    axi.margins(0)
    axi.set_title(f'T = {idx}')
    axi.set_xlabel("Node")
    axi.set_ylabel("Node",  labelpad = -5) 
    axi.set_facecolor('white')
    for i in "left right bottom top".split():
        axi.spines[i].set_visible(False)
    
fig.subplots_adjust(wspace = .05, hspace = .4)
fig.show()
#+end_src

#+attr_html: :alt  :align center :class img
[[file:./banner/ising_time_example.png]]

** Other parameters
The documentation is  a work in progress.  Please check out the  source code for
different models.
* Banner animation
** Setup
#+begin_src jupyter-python
from plexsim.models import *
n = 64
g = nx.grid_graph([n, n])

nx.set_node_attributes(g, {node : 0 for node in g.nodes()}, 'state')
idx = np.random.randint(len(list(g.nodes())))

node = list(g.nodes())[idx]

# print(nx.get_node_attributes(g, 'state')); assert 0
g.nodes[node]['state'] = 1

theta = .8
nx.set_node_attributes(g, {node : 0 if np.random.rand() < theta else 2\
                          for node in g.nodes()},\
                      'state')

settings = dict(graph = g,\
                updateType = 'async',\
#                 sampleSize = 1,\
)

import time
ti = time.time()

models = dict(
    Potts= Potts(t = .8, agentStates = np.arange(0, 5), **settings),
    Bonabeau = Bonabeau(agentStates = np.arange(3), eta = 0, **settings),
    AB = AB(**settings),
    Prisoner  = Prisoner(**settings),
    Ising = Ising(t = 2.2, **settings),
    Bornholdt = Bornholdt(t = .5, alpha = 4, **settings),
    RBN = RBN(**settings),
    SIRS = SIRS(mu = .2, nu = .02, kappa = .2, beta = .4, **settings),
    CCA = CCA(agentStates = np.arange(0,4).tolist(), threshold = .01, **settings),
    Percolation = Percolation(p = .01, **settings),
)
print(f"Settup time was {time.time() - ti}")
# models.get("Bornholdt").sampleSize = 1
if m := models.get("SIRS"):
    m.states = 0
    m.states[m.sampleNodes(1)[0,0]] = 1
    
if m := models.get("SIR"):
    m.states = 0
    m.states[m.sampleNodes(1)[0,0]] = 1
    
    
if m := models.get("Percolation"):
    m.states = 0
    m.states[m.sampleNodes(1)[0,0]] = 1
print("starting sims")

# mi = list(models.values())
# for i in mi:
#     print(i.memory.shape, i.memento)
# assert 0
T = 500
import time
start = time.time()

results = {}
for idx, (name, m) in enumerate(models.items()):
#     m.states = m.agentStates[-1]
    #m.reset()
    results[name] = m.simulate(T).reshape(T, n, n)
print(f'Simulation took {time.time() - start}')
#+end_src

#+RESULTS:
: Settup time was 0.8292031288146973
: starting sims
: Simulation took 6.801696300506592
    
** Animate
#+begin_src jupyter-python
import matplotlib.pyplot as plt
from ipywidgets import interact, IntSlider
import matplotlib as mpl
from mpl_toolkits.axes_grid1 import make_axes_locatable as mal
import cmasher as cmr
columns, rows = divmod(len(models), 2)
# columns = columns + 1 if not columns else columns
# rows = rows + 1 if not rows else rows
layout = np.zeros(len(models), dtype = object)
for idx, c in enumerate(models):
    layout[idx] = c
layout = layout.reshape(2, 5)
fig = plt.figure(figsize = (10,8), constrained_layout = 1)
ax = fig.subplot_mosaic(layout)
#setup figure/
hs  = {}
pad = .01
size = '5%'
for name, axi in ax.items():
    m = models[name]
    div = mal(axi)
    cbr = div.append_axes('bottom', size = size, pad = pad)
#     div = mal(cbr)
#     cbr = div.append_axes('right', size = size, pad = pad)
    AS = m.agentStates
    NS = len(AS) 
    cmap = mpl.colors.LinearSegmentedColormap.from_list(\
          None, cmr.pride(np.linspace(0, 1, NS, endpoint = 0)[:NS]), NS)
    
    h = axi.imshow(results[name][0], cmap = cmap, vmin = AS[0],\
                  vmax = AS[-1],
                   interpolation = None)
    axi.set_title(name, color = '#485ea4')
    axi.axis("off")
    #axi.spines['bottom'].set_color('red')
    #axi.spines['top'].set_color('red')
    
    tmp = fig.colorbar(h, cax = cbr, ticks = AS,\
                       orientation = 'horizontal')
    cbr.tick_params(colors = '#485ea4')
    if modelName == 'SIRS':
        tmp.set_ticklabels("Sus. Inf. Rec.".split())
    hs[name] = h
mainax = fig.add_subplot(111, frameon = 0,\
                        xticks = [], yticks = [])

text = mainax.annotate("", (.5, .05), xycoords = "axes fraction",
                       fontsize = 40, ha = 'center', va = 'center',
                       color = '#485ea4')
# fig.subplots_adjust(left = 0, right = 1, bottom = 0, top = 1)

fig.subplots_adjust(wspace = .02, hspace = -.2)
#fig.subplots_adjust(hspace = -.2)
fig.tight_layout()
def update(t):
    for name, h in hs.items(): 
        h.set_data(results[name][t])
#         h.autoscale()
    text.set_text(f'T = {t:03d}')
    fig.canvas.flush_events()
    fig.canvas.draw()
    return hs.values()
#fig.subplots_adjust(wspace = .02, hspace = .0)
from matplotlib.animation import FuncAnimation as FA
anim = FA(fig, update,
          frames = np.linspace(0, T, 10, endpoint = 0).astype(int),
          blit = 1,
          interval = 1)
anim.save('banner/new_banner.gif', dpi = 150, writer = 'ffmpeg',
          savefig_kwargs = dict(bbox_inches = "tight"))
print('done')
#+end_src

#+RESULTS:
:RESULTS:
: <ipython-input-117-83863b272bd6>:52: UserWarning: This figure was using constrained_layout==True, but that is incompatible with subplots_adjust and or tight_layout: setting constrained_layout==False. 
:   fig.subplots_adjust(wspace = .02, hspace = -.2)
: Warning: discarding the 'bbox_inches' argument in 'savefig_kwargs' as it may cause frame size to vary, which is inappropriate for animation.
: done
[[file:./.ob-jupyter/20d003fcd7a4901959117f68a9e0c2d500d6d01d.png]]
:END:



* Notes
Cannot have static pyobjects, this causes a segfault in pybind11. 
Use atexit for cleaning them up.


